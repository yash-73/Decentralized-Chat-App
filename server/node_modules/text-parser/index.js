"use strict";

var fs=require("fs");

class textParser {
    constructor(params) {
        if(!params.langs||!params.folder){
            throw "Not enougth params!";
        }
        this.langs = params.langs;
        this.folder = params.folder;
        this.lang = {};
        this.reloadLang();
    }
    parse(what, string, cb) {
        this.langs.forEach((lang)=>{
            if(!this.lang[lang][what]){
                this.lang[lang][what]=[];
                this.lang[lang][what][0]=what;
                this.saveLang();
            }else{
                this.lang[lang][what].forEach((regexp)=>{
                    this._parse(string,regexp,(out)=>{
                        cb(out);
                    });
                });
            }
        });
    }
    reloadLang() {
        this.langs.forEach((lang)=>{
            try{
                this.lang[lang]=require(`${this.folder}/${lang}.json`);
            }catch(err){
                this.lang[lang]={};
                this.saveLang();
            }
        });
    }
    saveLang() {
        this.langs.forEach((lang)=>{
            var toSave=JSON.stringify(this.lang[lang], null, 4);
            var fileName=`${this.folder}/${lang}.json`;
            fs.writeFile(fileName, toSave, function(err) {
                if(err){
                    throw err;
                }
            });
        });
    }
    _parse(string, regexp, callback) {
        var match = (regexp, text, cb) => {
            if (regexp.test(text)) {
                cb(text.match(regexp));
            }
        };

        var regexps = {
            "int": "[0-9]+",
            "string": "[a-zA-Zа-яА-Я]+",
            "any": ".+"
        };
        
        var allRegexps=Object.keys(regexps);
        allRegexps.forEach((regexp)=>{
            if(regexps[regexp][regexps[regexp].length-1]=="+"){
                var t=regexps[regexp].split("");
                t[t.length-1]="*";
                regexps[regexp+"_or_not"]=t.join("");
            }
            regexps[regexp]=regexps[regexp];
        });

        var parserStrings = [];

        match(/{{([a-zA-Z1-9:_]+)}}/g, regexp, cb => {
            cb.forEach((str) => {
                var strp = str.substring(2, str.length - 2).split(":");
                parserStrings.push(strp[0]);
                regexp = regexp.replace(str, `(${regexps[strp[1]]})`);
            });
        });

        regexp = new RegExp(`^${regexp}$`, "i");
        match(regexp, string, cb => {
            var out = {};
            parserStrings.forEach((text, index) => {
                out[text] = trim(cb[index + 1]);
            });
            callback(out);
            return;
        });
    };
}

module.exports = textParser;

var trim=(str)=>{
    return str.toString().replace(/^\s+/, '').replace(/\s+$/, '').toString();
};